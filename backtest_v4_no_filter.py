# -*- coding: utf-8 -*-
"""
================================================================================
V4 ç„¡æ¿¾ç¶²å›æ¸¬è…³æœ¬ (No Buy Filter Backtest)
================================================================================
æ¸¬è©¦ V4 æ¨¡å‹åœ¨å–æ¶ˆ Signal_Buy_Filter é™åˆ¶ä¸‹çš„äº¤æ˜“ç¸¾æ•ˆã€‚
æ¯ä¸€å¤©éƒ½å¯ä»¥è€ƒæ…®è²·é€²ï¼Œè€Œéåƒ…åœ¨ Donchian çªç ´æ—¥ã€‚

ç”¨é€”ï¼š
- è©•ä¼° Buy Filter å°ç¸¾æ•ˆçš„è²¢ç»åº¦
- æ¯”è¼ƒæœ‰/ç„¡æ¿¾ç¶²çš„äº¤æ˜“æ¬¡æ•¸èˆ‡å‹ç‡å·®ç•°

ä½œè€…ï¼šPhil Liang (Generated by Gemini)
æ—¥æœŸï¼š2025-12-08
================================================================================
"""

import os
import sys
import pickle
from datetime import datetime

# Windows UTF-8 è¨­å®š
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from stable_baselines3 import PPO

# ä¸­æ–‡å­—å‹è¨­å®š
plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

# =============================================================================
# è¨­å®š
# =============================================================================
PROJECT_PATH = os.path.dirname(os.path.abspath(__file__))
V4_MODELS_PATH = os.path.join(PROJECT_PATH, 'models_hybrid_v4')
RESULTS_PATH = os.path.join(PROJECT_PATH, 'results_backtest_v4_no_filter')
CACHE_DIR = os.path.join(PROJECT_PATH, 'data', 'processed')

SPLIT_DATE = '2023-01-01'  # å›æ¸¬èµ·å§‹æ—¥
INITIAL_CAPITAL = 1_000_000


# =============================================================================
# ç„¡æ¿¾ç¶²å›æ¸¬å™¨
# =============================================================================
class NoFilterBacktester:
    """
    ç„¡æ¿¾ç¶²å›æ¸¬å™¨ï¼šæ¯å¤©éƒ½è€ƒæ…®è²·é€²è¨Šè™Ÿï¼Œä¸å— Signal_Buy_Filter é™åˆ¶
    """
    def __init__(self, buy_model, sell_model, initial_capital=1_000_000):
        self.buy_model = buy_model
        self.sell_model = sell_model
        self.initial_capital = initial_capital
        self.trades = []
        self.equity_curve = []
        self.buy_signals = []
        self.sell_signals = []
    
    def run(self, df: pd.DataFrame, feature_cols: list) -> dict:
        """åŸ·è¡Œç„¡æ¿¾ç¶²å›æ¸¬"""
        capital = self.initial_capital
        position = None
        
        features = df[feature_cols].values.astype(np.float32)
        close_prices = df['Close'].values
        dates = df.index
        
        print(f"[Backtest] å›æ¸¬æœŸé–“: {dates[0].strftime('%Y-%m-%d')} ~ {dates[-1].strftime('%Y-%m-%d')}")
        print(f"[Backtest] è³‡æ–™ç­†æ•¸: {len(df)}")
        print(f"[Backtest] åˆå§‹è³‡é‡‘: ${capital:,.0f}")
        print("[Backtest] æ¨¡å¼: ç„¡æ¿¾ç¶² (æ¯å¤©éƒ½å¯è²·é€²)")
        
        for i in range(len(df)):
            date = dates[i]
            price = close_prices[i]
            
            # è¨˜éŒ„æ¯æ—¥æ·¨å€¼
            if position is not None:
                current_value = capital + position['shares'] * price
            else:
                current_value = capital
            self.equity_curve.append({'date': date, 'value': current_value})
            
            # è™•ç† NaN
            obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0)
            
            # =====================================================================
            # æŒæœ‰ä¸­ï¼šæª¢æŸ¥è³£å‡º
            # =====================================================================
            if position is not None:
                hold_days = i - position['buy_idx']
                current_return = price / position['buy_price']
                
                # Sell Agent è§€å¯Ÿ (Features + Current Return)
                sell_obs = np.concatenate([obs, [current_return]]).astype(np.float32)
                action, _ = self.sell_model.predict(sell_obs.reshape(1, -1), deterministic=True)
                
                # åœæ/åœåˆ©/AIæ±ºç­–/è¶…æ™‚
                stop_loss = current_return < 0.92  # -8% åœæ
                should_sell = action[0] == 1 or stop_loss or hold_days >= 120
                
                if should_sell:
                    sell_value = position['shares'] * price
                    profit = sell_value - position['shares'] * position['buy_price']
                    capital += sell_value
                    
                    self.trades.append({
                        'buy_date': position['buy_date'],
                        'buy_price': position['buy_price'],
                        'sell_date': date,
                        'sell_price': price,
                        'return': current_return - 1,
                        'profit': profit,
                        'hold_days': hold_days
                    })
                    self.sell_signals.append((date, price))
                    position = None
            
            # =====================================================================
            # ç©ºæ‰‹ï¼šæ¯å¤©éƒ½æª¢æŸ¥è²·å…¥ (ç„¡æ¿¾ç¶²)
            # =====================================================================
            elif position is None:
                buy_obs = obs.reshape(1, -1)
                action, _ = self.buy_model.predict(buy_obs, deterministic=True)
                
                if action[0] == 1:  # Buy
                    invest_amount = capital * 0.9
                    shares = int(invest_amount / price)
                    
                    if shares > 0:
                        cost = shares * price
                        capital -= cost
                        
                        position = {
                            'shares': shares,
                            'buy_price': price,
                            'buy_date': date,
                            'buy_idx': i
                        }
                        self.buy_signals.append((date, price))
        
        return self._calculate_metrics(df)
    
    def _calculate_metrics(self, df: pd.DataFrame) -> dict:
        """è¨ˆç®—ç¸¾æ•ˆæŒ‡æ¨™"""
        if not self.equity_curve:
            return {}
        
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df['date'] = pd.to_datetime(equity_df['date'])
        equity_df.set_index('date', inplace=True)
        
        initial = self.initial_capital
        final = equity_df['value'].iloc[-1]
        total_return = (final - initial) / initial
        
        days = (equity_df.index[-1] - equity_df.index[0]).days
        years = days / 365.0
        annualized_return = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
        
        daily_returns = equity_df['value'].pct_change().dropna()
        if len(daily_returns) > 0 and daily_returns.std() > 0:
            sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
        else:
            sharpe = 0
        
        rolling_max = equity_df['value'].cummax()
        drawdown = (equity_df['value'] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        
        if self.trades:
            wins = sum(1 for t in self.trades if t['return'] > 0)
            win_rate = wins / len(self.trades)
            avg_return = np.mean([t['return'] for t in self.trades])
            avg_hold_days = np.mean([t['hold_days'] for t in self.trades])
        else:
            win_rate = 0
            avg_return = 0
            avg_hold_days = 0
        
        return {
            'initial_capital': initial,
            'final_value': final,
            'total_return': total_return,
            'annualized_return': annualized_return,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_drawdown,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'avg_return': avg_return,
            'avg_hold_days': avg_hold_days,
            'equity_df': equity_df
        }


# =============================================================================
# ä¸»ç¨‹å¼
# =============================================================================
def main():
    print("=" * 60)
    print("V4 ç„¡æ¿¾ç¶²å›æ¸¬ (No Buy Filter Backtest)")
    print("=" * 60)
    
    # å»ºç«‹è¼¸å‡ºç›®éŒ„
    os.makedirs(RESULTS_PATH, exist_ok=True)
    
    # =========================================================================
    # è¼‰å…¥æ¨¡å‹
    # =========================================================================
    print("\n[Model] è¼‰å…¥ V4 æ¨¡å‹...")
    buy_path = os.path.join(V4_MODELS_PATH, 'ppo_buy_twii_final.zip')
    sell_path = os.path.join(V4_MODELS_PATH, 'ppo_sell_twii_final.zip')
    
    if not os.path.exists(buy_path):
        print(f"[Error] æ¨¡å‹ä¸å­˜åœ¨: {buy_path}")
        print("è«‹å…ˆåŸ·è¡Œ train_v4_models.py")
        sys.exit(1)
    
    buy_model = PPO.load(buy_path)
    sell_model = PPO.load(sell_path)
    print("  âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ")
    
    # =========================================================================
    # è¼‰å…¥/è¨ˆç®—ç‰¹å¾µè³‡æ–™
    # =========================================================================
    print("\n[Data] æº–å‚™å›æ¸¬è³‡æ–™...")
    import ptrl_hybrid_system as hybrid
    
    hybrid.load_best_lstm_models()
    
    cache_path = os.path.join(CACHE_DIR, "_TWII_features.pkl")
    if os.path.exists(cache_path):
        print(f"  [Cache] è¼‰å…¥å¿«å–: {cache_path}")
        with open(cache_path, 'rb') as f:
            twii_full_df = pickle.load(f)
    else:
        print("  [Compute] ä¸‹è¼‰ä¸¦è¨ˆç®—ç‰¹å¾µ...")
        twii_raw = yf.download("^TWII", start="2000-01-01", auto_adjust=True, progress=False)
        if isinstance(twii_raw.columns, pd.MultiIndex):
            twii_raw.columns = twii_raw.columns.get_level_values(0)
        twii_full_df = hybrid.calculate_features(twii_raw, twii_raw, ticker="^TWII", use_cache=True)
    
    # åˆ†å‰²å›æ¸¬è³‡æ–™
    split_date = pd.Timestamp(SPLIT_DATE)
    twii_backtest_df = twii_full_df[twii_full_df.index >= split_date]
    print(f"  å›æ¸¬æœŸé–“: {twii_backtest_df.index[0].strftime('%Y-%m-%d')} ~ {twii_backtest_df.index[-1].strftime('%Y-%m-%d')}")
    print(f"  è³‡æ–™ç­†æ•¸: {len(twii_backtest_df)}")
    
    # =========================================================================
    # åŸ·è¡Œå›æ¸¬
    # =========================================================================
    print("\n[Backtest] é–‹å§‹ç„¡æ¿¾ç¶²å›æ¸¬...")
    backtester = NoFilterBacktester(buy_model, sell_model, INITIAL_CAPITAL)
    metrics = backtester.run(twii_backtest_df, hybrid.FEATURE_COLS)
    
    # =========================================================================
    # å°å‡ºç¸¾æ•ˆ
    # =========================================================================
    print("\n" + "=" * 60)
    print("ğŸ“Š ç¸¾æ•ˆæ‘˜è¦ (ç„¡æ¿¾ç¶² V4)")
    print("=" * 60)
    print(f"  åˆå§‹è³‡é‡‘:   ${metrics['initial_capital']:,.0f}")
    print(f"  æœ€çµ‚æ·¨å€¼:   ${metrics['final_value']:,.0f}")
    print(f"  ç¸½å ±é…¬ç‡:   {metrics['total_return']*100:+.2f}%")
    print(f"  å¹´åŒ–å ±é…¬:   {metrics['annualized_return']*100:+.2f}%")
    print(f"  å¤æ™®å€¼:     {metrics['sharpe_ratio']:.2f}")
    print(f"  æœ€å¤§å›æ’¤:   {metrics['max_drawdown']*100:.2f}%")
    print("-" * 60)
    print(f"  äº¤æ˜“æ¬¡æ•¸:   {metrics['total_trades']}")
    print(f"  å‹ç‡:       {metrics['win_rate']*100:.1f}%")
    print(f"  å¹³å‡å ±é…¬:   {metrics['avg_return']*100:+.2f}%")
    print(f"  å¹³å‡æŒæœ‰:   {metrics['avg_hold_days']:.1f} å¤©")
    print("=" * 60)
    
    # =========================================================================
    # è¦–è¦ºåŒ–
    # =========================================================================
    fig, axes = plt.subplots(2, 1, figsize=(14, 10))
    
    # å­åœ– 1: Portfolio Value vs Benchmark
    ax1 = axes[0]
    equity_df = metrics['equity_df']
    
    ax1.plot(equity_df.index, equity_df['value'], label='V4 (No Filter)', color='blue', linewidth=2)
    
    # Benchmark
    bench_slice = twii_full_df.loc[equity_df.index[0]:equity_df.index[-1]]['Close']
    bench_normalized = bench_slice / bench_slice.iloc[0] * INITIAL_CAPITAL
    ax1.plot(bench_normalized.index, bench_normalized.values, 
             label='^TWII Buy & Hold', color='gray', linewidth=1.5, alpha=0.7)
    
    ax1.set_title('V4 ç„¡æ¿¾ç¶²å›æ¸¬ vs å¤§ç›¤ (2023-Present)', fontsize=14)
    ax1.set_ylabel('Portfolio Value ($)')
    ax1.legend(loc='upper left')
    ax1.grid(True, alpha=0.3)
    
    # å­åœ– 2: Price with Signals
    ax2 = axes[1]
    price_slice = twii_backtest_df['Close']
    ax2.plot(price_slice.index, price_slice.values, label='^TWII Close', color='black', linewidth=1)
    
    if backtester.buy_signals:
        buy_dates, buy_prices = zip(*backtester.buy_signals)
        ax2.scatter(buy_dates, buy_prices, marker='^', color='red', s=100, label='Buy', zorder=5)
    
    if backtester.sell_signals:
        sell_dates, sell_prices = zip(*backtester.sell_signals)
        ax2.scatter(sell_dates, sell_prices, marker='v', color='green', s=100, label='Sell', zorder=5)
    
    ax2.set_title('äº¤æ˜“è¨Šè™Ÿ (ç„¡æ¿¾ç¶²)', fontsize=14)
    ax2.set_ylabel('Price')
    ax2.set_xlabel('Date')
    ax2.legend(loc='upper left')
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # å„²å­˜åœ–è¡¨
    save_path = os.path.join(RESULTS_PATH, 'backtest_v4_no_filter.png')
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"\n[Output] åœ–è¡¨å·²å„²å­˜: {save_path}")
    plt.close()
    
    # =========================================================================
    # å„²å­˜äº¤æ˜“æ˜ç´°
    # =========================================================================
    if backtester.trades:
        trades_df = pd.DataFrame(backtester.trades)
        trades_path = os.path.join(RESULTS_PATH, 'trades_v4_no_filter.csv')
        trades_df.to_csv(trades_path, index=False)
        print(f"[Output] äº¤æ˜“æ˜ç´°: {trades_path}")
        
        print("\n[Trades] æœ€è¿‘ 5 ç­†äº¤æ˜“:")
        print(trades_df.tail().to_string(index=False))
    
    print("\n" + "=" * 60)
    print("âœ… å›æ¸¬å®Œæˆï¼")
    print("=" * 60)


if __name__ == "__main__":
    main()
